import asyncio
import logging
import os
import json
import io
import wave
import base64
import aiohttp
from aiohttp import web

from aiogram import Bot, Dispatcher, Router, types
from aiogram.enums import ParseMode
from aiogram.types import BotCommand, BufferedInputFile
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.client.bot import DefaultBotProperties
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application

# =========================
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
# =========================
# –ú—ã –±—É–¥–µ–º –±—Ä–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞ —Ö–æ—Å—Ç–∏–Ω–≥–µ.
# –°–¥–µ–ª–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ–π, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫.
BOT_TOKEN = os.getenv("BOT_TOKEN")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
WEB_SERVER_HOST = os.getenv("WEB_SERVER_HOST", "0.0.0.0")
WEB_SERVER_PORT = int(os.getenv("PORT", 8080))
WEBHOOK_PATH = os.getenv("WEBHOOK_PATH", "/webhook")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

# –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã.
if not all([BOT_TOKEN, GOOGLE_API_KEY, WEBHOOK_URL]):
    logging.error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è BOT_TOKEN, GOOGLE_API_KEY –∏ WEBHOOK_URL.")
    raise RuntimeError("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)

router = Router()

# =========================
# –°–æ—Å—Ç–æ—è–Ω–∏—è FSM –¥–ª—è TTS
# =========================
class TTSStates(StatesGroup):
    waiting_for_text = State()

# =========================
# –•–µ–Ω–¥–ª–µ—Ä—ã
# =========================
@router.message(CommandStart())
async def cmd_start(message: types.Message):
    """
    Handles the /start command.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /start.
    """
    await message.answer("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.")

@router.message(Command("help"))
async def cmd_help(message: types.Message):
    """
    Handles the /help command.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /help.
    """
    commands_list = (
        "–°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥:\n"
        "/speak - –ü—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ –≥–æ–ª–æ—Å\n"
    )
    await message.answer(commands_list)

@router.message(Command("speak"))
async def cmd_speak(message: types.Message, state: FSMContext):
    """
    Starts the text-to-speech process.
    –ù–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –≤ –≥–æ–ª–æ—Å.
    """
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –æ–∑–≤—É—á–∏—Ç—å.")
    await state.set_state(TTSStates.waiting_for_text)

@router.message(TTSStates.waiting_for_text)
async def process_tts_text(message: types.Message, state: FSMContext):
    """
    Receives text from the user and sends a request to the Gemini API for TTS.
    –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—Å—Ç –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ Gemini API –¥–ª—è TTS.
    """
    await state.clear()
    
    processing_msg = await message.answer("‚è≥ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∞—É–¥–∏–æ...")
    
    text_to_speak = message.text
    
    payload = {
        "contents": [
            { "parts": [ { "text": text_to_speak } ] }
        ],
        "generationConfig": {
            "responseModalities": ["AUDIO"],
            "speechConfig": {
                "voiceConfig": { "prebuiltVoiceConfig": { "voiceName": "Kore" } }
            }
        },
        "model": "gemini-2.5-flash-preview-tts"
    }
    
    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key={GOOGLE_API_KEY}"
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(api_url, json=payload) as response:
                response.raise_for_status()
                data = await response.json()
                
                audio_data = data.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("inlineData", {}).get("data")
                mime_type = data.get("candidates", [{}])[0].get("content", {}).get("parts", [{}])[0].get("inlineData", {}).get("mimeType")
                
                if audio_data and mime_type.startswith("audio/"):
                    pcm_data = base64.b64decode(audio_data)
                    
                    sample_rate_match = mime_type.split(';')[0].split('rate=')[1]
                    sample_rate = int(sample_rate_match)
                    
                    output = io.BytesIO()
                    with wave.open(output, 'wb') as wav_file:
                        wav_file.setnchannels(1)
                        wav_file.setsampwidth(2)
                        wav_file.setframerate(sample_rate)
                        wav_file.writeframes(pcm_data)
                    
                    output.seek(0)
                    
                    await message.answer_voice(
                        voice=BufferedInputFile(output.getvalue(), filename="audio.wav"),
                        caption=f"–í–∞—à–µ –∞—É–¥–∏–æ –≥–æ—Ç–æ–≤–æ! ‚ú®"
                    )
                else:
                    await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∞—É–¥–∏–æ.")
                    
    except aiohttp.ClientError as e:
        logging.error(f"–û—à–∏–±–∫–∞ HTTP-–∑–∞–ø—Ä–æ—Å–∞: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ API. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ.")
    except Exception as e:
        logging.error(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞.")
    finally:
        await processing_msg.delete()

@router.message()
async def fallback(message: types.Message):
    """
    Handles any unknown messages.
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ª—é–±—ã–µ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.
    """
    await message.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ù–∞–ø–∏—à–∏—Ç–µ /help, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–∞–Ω–¥.")

# =========================
# –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ —Å –≤–µ–±—Ö—É–∫–∞–º–∏
# =========================
async def on_startup(dispatcher: Dispatcher, bot: Bot):
    """
    Sets up the webhook on bot startup.
    –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –≤–µ–±—Ö—É–∫ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞.
    """
    await bot.set_webhook(f"{WEBHOOK_URL}{WEBHOOK_PATH}", drop_pending_updates=True)
    await bot.set_my_commands([
        BotCommand(command="start", description="–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"),
        BotCommand(command="help", description="–ü–æ–º–æ—â—å"),
        BotCommand(command="speak", description="–ü—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ –≥–æ–ª–æ—Å"),
    ])
    logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω —Å –≤–µ–±—Ö—É–∫–∞–º–∏.")

async def on_shutdown(dispatcher: Dispatcher, bot: Bot):
    """
    Deletes the webhook on bot shutdown.
    –£–¥–∞–ª—è–µ—Ç –≤–µ–±—Ö—É–∫ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –±–æ—Ç–∞.
    """
    await bot.delete_webhook()
    logging.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

def main():
    """
    Main function to run the bot with aiohttp web server.
    –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞ —Å –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–æ–º aiohttp.
    """
    # –î–æ–±–∞–≤–ª—è–µ–º DefaultBotProperties –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å aiogram 3.0+
    bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.MARKDOWN_V2))
    dp = Dispatcher()
    dp.include_router(router)
    
    app = web.Application()
    
    # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É AttributeError, –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤–µ–±—Ö—É–∫–æ–≤
    handler = SimpleRequestHandler(dispatcher=dp, bot=bot)
    handler.register(app, path=WEBHOOK_PATH)
    
    setup_application(app, dp, bot=bot)

    app.on_startup.append(lambda app, bot=bot: asyncio.create_task(on_startup(dp, bot)))
    app.on_shutdown.append(lambda app, bot=bot: asyncio.create_task(on_shutdown(dp, bot)))

    web.run_app(app, host=WEB_SERVER_HOST, port=WEB_SERVER_PORT)

if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, SystemExit):
        logging.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
